import time
import asyncio
from selenium import webdriver
from selenium.webdriver.chrome.service import Service
from selenium.webdriver.chrome.options import Options
from webdriver_manager.chrome import ChromeDriverManager
from selenium.webdriver.common.desired_capabilities import DesiredCapabilities
from selenium.webdriver.common.action_chains import ActionChains
from selenium.common.exceptions import MoveTargetOutOfBoundsException
from multiprocessing import shared_memory
import os
from threading import Thread
import json
import websockets
import asyncio
import time
from logger_config import logger
from threading import RLock
from google import genai
from google.genai import types 
from google.genai.types import HttpOptions
from google.cloud import vision
import base64
from multiprocessing.shared_memory import SharedMemory
from bs4 import BeautifulSoup
from selenium.webdriver.common.by import By

# scripts

"""
This file have 3 parts .
1. WebSocketClient : A class to handle the websocket client
2. selenium_manager : A class to handle the selenium operations
3. main : The main function to start the websocket client and selenium driver

This works like such in a short .
we connect to the same room where user is connected .
to handle the authentication we use a token to connect to the room .
the token is generated by the server and is unique for each user .
we request the token from the frontend
then we connect to the room with the token
then we send a register message to the server to ensure the connection to the server
then we listen to the messages from the server
then we see if shared memory is available
then we test the shared memory
then we setup the selenium driver
then we hit the url on the browser
then we capture the screenshot and audio in a loop and write to shared memory
we do all this in a thread
then we keep the main thread alive to keep the script running
then we handle the messages from the server
the messages are of 4 types
    1. register : to register the user
    2. click_on_driver : to click on the driver
    3. search : to search on the driver
    4. keypress : to type on the driver
    5. hover : to hover on the driver
    6. hello : to say hello to the server
    7. error : to say error to the server
Message flow :
    1. messages comes to the socket client from the server
    2. the messages are handled by the handle_message function
    3. the messages are then passed to the trigger_bridge function
    4. the trigger_bridge function then calls the respective function to handle the message
    5. the functions are click_on_driver, search_on_driver, type_on_driver, hover_on_driver
    6. the functions then handle the operation on the driver
    7. the operation is then completed
"""

"""
WebSocket client to connect to the server and send/receive messages.
input:
    --uri: str : WebSocket server URI
    --user_id: str : Unique user ID
    --auth_token: str : Authentication token for the WebSocket server
algorithm:
    functions available:
        --start_in_thread : start operation in thread
        --run : run the event loop in a thread
        --connect : connect to the websocket server
        --send_message : send message to the websocket server
        --listen : listen for messages from the server
        --handle_message : handle incoming messages
        --close : close the websocket connection
        --send_message_thread_safe : send message from outside the websocket event loop
output:
    None
"""
class WebSocketClient:
    """
    WebSocket client to connect to the server and send/receive messages.
    input:
        --uri: str : WebSocket server URI
        --user_id: str : Unique user ID
        --auth_token: str : Authentication token for the WebSocket server
    algorithm:
        None
    output:
        None
    """
    def __init__(
        self, 
        uri, 
        user_id, 
        auth_token,
        ip
    ):
        self.uri = uri
        self.user_id = user_id
        self.auth_token = auth_token  
        self.websocket = None
        self.ip = ip
        self.loop = asyncio.new_event_loop()
    
    """
    start operation in thread
    input:
        None
    algorithm:
        --create a thread
        --start the thread
    output:
        None
    """
    def start_in_thread(
        self
    ):
        thread = Thread(
            target=self.run, 
            daemon=True
        )
        thread.start()

    """ 
    run the event loop in a thread
    input:
        None
    algorithm:
        --set the event loop
        --run the event loop
    output:
        None
    """
    def run(
        self
    ):
        asyncio.set_event_loop(
            self.
            loop
        )
        self.loop.run_until_complete(
            self.connect()
        )

    """
    connect to the websocket server
    input:
        None
    algorithm:
        --create headers for the connection
        --connect to the websocket server
        --send registration message
        --listen for messages
    output:
        None
    """
    async def connect(
        self
    ):
        # Gets the primary network interface's IP address
        logger.warning(f"Local IP Address:{self.ip}")
        try:
            headers = {
                'Origin':f"http://{self.ip}:8000",
                "Authorization": f"Bearer {self.auth_token}"
            }
            logger.debug(f"trying to connect to {self.uri}")
            self.websocket = await websockets.connect(
                self.uri, 
                additional_headers=headers
            )
            logger.info(f"[ CLIENT ] Connected to server at {self.uri} with authentication.")

            # Send registration message
            await self.send_message(
                type="register", 
                message="register request"
            )
            logger.info(f"[ CLIENT ] Sent registration message for user_id: {self.user_id}")
            # Start listening for server messages
            await self.listen()
        except Exception as e:
            logger.error(f"[ CLIENT ] Connection error: {e}")

    """
    send message to the websocket server
    input:
        --type: str : type of message
        --message: str : message to send
    algorithm:
        --send message
    output:
        None
    """
    async def send_message(
        self, 
        type, 
        message
    ):
        """Send a message over WebSocket."""
        if self.websocket:
            try:
                message_payload = {
                    "special": type,
                    "user_id": self.user_id,
                    "message": message,
                }
                await self.websocket.send(
                    json.dumps(
                        message_payload
                        )
                    )
                logger.info(f"[ CLIENT ] Sent message: {len(message_payload)}")
            except Exception as e:
                logger.error(f"[ CLIENT ] Error sending message: {e}")
        else:
            logger.warning("[ CLIENT ] WebSocket is not connected.")

    """
    listen for messages from the server
    input:
        None
    algorithm:
        --listen for messages
        --handle messages
    output:
        None
    """
    async def listen(
        self
    ):
        """Listen for messages from the server."""
        try:
            async for message in self.websocket:
                logger.info(f"[ CLIENT ] Received message: {len(message)}")
                await self.handle_message(
                    message
                )
        except Exception as e:
            logger.error(f"[ CLIENT ] Listening error: {e}")

    """
    handle incoming messages
    input:
        --message: str : incoming message
    algorithm:
        --handle message and set triggers
    output:
        None
    """
    async def handle_message(
        self, 
        message
    ):
        logger.warning(f'{message}')
        data = json.loads(message)
        if data.get("type") == "register":
            logger.info(f"[ CLIENT ] Registration successful for user_id: {self.user_id}")
            # Send hello message
            await self.send_message(
                type="hello", 
                message="Hello, server!"
            )
        if data.get("type") == "click_on_driver":
            logger.info(f"[ CLIENT ] click request for user_id: {self.user_id}")
            logger.warning(data)
            SM.trigger_bridge(
                type="click_on_driver",
                message=data
            )
            logger.warning("[ CLIENT ] click complete .")
        if data.get("type") == "search":
            logger.info(f"[ CLIENT ] search request for user_id: {self.user_id}")
            logger.warning(data)
            SM.trigger_bridge(
                type="search",
                message=data
            )
            logger.warning("[ CLIENT ] search complete .")
        if data.get("type") == "keypress":
            logger.info(f"[ CLIENT ] key press request for user_id: {self.user_id}")
            logger.warning(data)
            SM.trigger_bridge(
                type="keypress",
                message=data
            )
            logger.warning("[ CLIENT ] keypress complete .")
        if data.get("type") == "hover":
            logger.info(f"[ CLIENT ] hover request for user_id: {self.user_id}")
            logger.warning(data)
            SM.trigger_bridge(
                type="hover",
                message=data
            )
            logger.warning("[ CLIENT ] hover complete .")
        if data.get("type") == "page_source":
            logger.info(f"[ CLIENT ] page source request for user_id: {self.user_id}")
            logger.warning(data)
            SM.trigger_bridge(
                type="page_source",
                message=data
            )
            logger.warning("[ CLIENT ] page source complete .")
        if data.get("type") == "LLM_ask_a_text":
            logger.info(f"[ CLIENT ] [ LLM ]  ask a text request for user_id: {self.user_id}")
            logger.warning(data)
            await GAC.trigger_bridge(
                type="LLM_ask_a_text",
                message=data
            )
            logger.warning("[ CLIENT ] [ LLM ] ask a text complete .")
        if data.get("type") == "vision_ask_a_vision":
            logger.info(f"[ CLIENT ] [ VISION ]  VISION request for user_id: {self.user_id}")
            logger.warning(data)
            await VA.trigger_bridge(
                type="vision_ask_a_vision",
                message=data
            )
            logger.warning("[ CLIENT ] [ VISION ] ask a vision complete .")
        elif data.get("type") == "hello":
            logger.info(f"[ CLIENT ] Server says: {data['message']}")

    """
    close the websocket connection
    input:
        None
    algorithm:
        --close the websocket connection
    output:
        None
    """
    async def close(
        self
    ):
        if self.websocket:
            await self.websocket.close()
            logger.info("[ CLIENT ] WebSocket connection closed.")

    """
    send message from outside the websocket event loop
    input:
        --type: str : type of message
        --message: str : message to send
    algorithm:
        --send message
    output:
        None
    """
    def send_message_thread_safe(
        self, 
        type, 
        message
    ):
        if self.loop.is_running():
            asyncio.run_coroutine_threadsafe(
                self.send_message(
                    type=type, 
                    message=message
                ), 
                self.loop
            )
        else:
            logger.warning("[ CLIENT ] WebSocket event loop is not running.")

"""
selenium manager to handle selenium operations
input:
    None
algorithm:
    --setup selenium driver
    --trigger bridge
    --click on driver
    --type on driver
    --search on driver
    --hover on driver
    --write to shared memory
    --hit url on browser
    --prepare browser for audio
    --clear and track log
    --capture and write screenshot and audio
output:
    None
"""
class selenium_manager:
    """
    set the credentials for the selenium manager
    input:
        None
    algorithm:
        --set the credentials
    output:
        None
    """
    def __init__(self):
        self.driver = None
        self.driver_lock = RLock()
        self.driver_instruction = None
        self.driver_message = None
        self.default_url = "https://cse.google.com/cse?cx=e5856f31c6fb143cb"
        self.source = None
        self.llm_message_type = None
        self.llm_message = None
        self.llm = None
        self.page_view_data = None
        self.summarized_page_view_data = None
    
    """
    setup selenium driver
    input:
        input:
            None
    algorithm:
        --setup and return a selenium driver
        --resize the window
    output:
        None
    """
    def setup_selenium_driver(
        self
    ):
        """Setup and return a Selenium WebDriver instance."""
        start_time = time.time()
        chrome_options = Options()
        chrome_options.add_argument("--no-sandbox")
        chrome_options.add_argument("--headless")
        chrome_options.add_argument("--disable-dev-shm-usage")
        chrome_options.set_capability("goog:loggingPrefs", {"browser": "ALL"})
        main_driver = webdriver.Chrome(
            service=Service(ChromeDriverManager().install()), options=chrome_options
        )
        outer_width = main_driver.execute_script("return window.outerWidth;")
        inner_width = main_driver.execute_script("return window.innerWidth;")
        outer_height = main_driver.execute_script("return window.outerHeight;")
        inner_height = main_driver.execute_script("return window.innerHeight;")
        width_diff = outer_width - inner_width
        height_diff = outer_height-inner_height
        n_screen_width = screen_width + width_diff
        n_screen_height = screen_height + height_diff
        main_driver.set_window_size(n_screen_width, n_screen_height)
        end_time = time.time()
        logger.info(f"[ SETUP ] Selenium WebDriver setup took {end_time - start_time:.4f} seconds")
        self.driver =  main_driver
    
    """
    A function handling all the triggers from the websocket
    input:
        --type: str : type of trigger
        --message: str : message to send
    algorithm:
        --trigger the bridge on the type and call the respective function
        functions:
            --click on driver : click on the driver
            --type on driver : type on the driver
            --search on driver : search on the driver
            --hover on driver : hover on the driver
    output:
        None
    """
    def trigger_bridge(
        self,
        type, 
        message
    ):
        if type == "click_on_driver":
            try:
                logger.debug("trying to set up click on driver")
                self.driver_message = "click_on_driver"
                self.driver_instruction = message
                logger.debug("set up click on driver . handing over tto tread")
            except  Exception as e:
                logger.error(f"Error in clicking driver: {e}")
        elif type == "search":
            try:
                logger.debug("trying to set up search on driver")
                self.driver_message = "search"
                self.driver_instruction = message
                logger.debug("set up search on driver . handing over tto tread")
            except  Exception as e:
                logger.error(f"Error in clicking driver: {e}")
        elif type == "keypress":
            try:
                logger.debug("trying to set up key pressed onn driver")
                self.driver_message = "keypress"
                self.driver_instruction = message
                logger.debug("set up keypress onn driver . hhanding over tto tread")
            except  Exception as e:
                logger.error(f"Error in clicking driver: {e}")
        elif type == "hover":
            try:
                logger.debug("trying to set up hover onn driver")
                self.driver_message = "hover"
                self.driver_instruction = message
                logger.debug("set up hover onn driver . hhanding over tto tread")
            except  Exception as e:
                logger.error(f"Error in hovering driver: {e}")
        elif type == "page_source":
            try:
                logger.debug("trying to set up page source onn driver")
                self.driver_message = "page_source"
                self.driver_instruction = message
                logger.debug("set up page ssource onn driver . hhanding over tto tread")
            except  Exception as e:
                logger.error(f"Error in hovering driver: {e}")

    def set_page_source(self,driver):
        logger.debug("setting up page source")
        self.source = driver.page_source
        logger.debug("page source set")
        return driver
    
    def get_elements_in_viewport(self, driver):
        logger.info("Processing page viewport elements")
        data = []

        # Get all elements of interest
        buttons = driver.find_elements(By.TAG_NAME, "button")
        inputs = driver.find_elements(By.TAG_NAME, "input")
        _as = driver.find_elements(By.TAG_NAME, "a")
        imgs = driver.find_elements(By.TAG_NAME, "img")
        all_elems = buttons + inputs + _as + imgs

        for element in all_elems:
            visible_text = element.text.strip() if element.text else None
            is_visible, rect_cords = driver.execute_script("""
                function isElementInViewport(el) {
                    if (!el) return [false, null];
                    const rect = el.getBoundingClientRect();
                    const inViewport = (
                        rect.top >= 0 &&
                        rect.left >= 0 &&
                        rect.bottom <= window.innerHeight &&
                        rect.right <= window.innerWidth
                    );
                    return [inViewport, rect];
                }
                return isElementInViewport(arguments[0]);
            """, element)

            if is_visible:
                # Extract element attributes
                all_attrs = driver.execute_script('''
                    var items = {}; 
                    for (var i = 0; i < arguments[0].attributes.length; i++) {
                        items[arguments[0].attributes[i].name] = arguments[0].attributes[i].value;
                    }
                    return items;
                ''', element)

                data.append({
                    'tag': element.tag_name,
                    'text': visible_text,
                    'attributes': all_attrs,
                    'rect': {
                        'top': rect_cords['top'],
                        'left': rect_cords['left'],
                        'width': rect_cords['width'],
                        'height': rect_cords['height']
                    }
                })
                self.page_view_data = data
                summarized_page_view_data = {}
                for d in data:
                    if d['tag'] in summarized_page_view_data.keys():
                        summarized_page_view_data[d].append(
                                d['text']
                        )
                    else:
                        summarized_page_view_data[d['tag']] = [d['tag']]
        logger.info(f"Processed {len(data)} elements in viewport")
        return driver , summarized_page_view_data

    """
    click on the driver
    input:
        --driver: selenium driver : driver to click on
        --x: int : x coordinate
        --y: int : y coordinate
    algorithm:
        --lock the driver
        --get the outer and inner dimensions
        --get the element at the x and y coordinates
        --click on the element
    output:
        --driver: selenium driver : driver after the click
    """        
    def click_on_driver(
        self,
        driver,
        x, 
        y
    ):
        logger.warning("starting clickinng process")
        logger.warning("locked .")
        if driver:
            # outer_width = driver.execute_script(
            #     "return window.outerWidth;")
            # inner_width = driver.execute_script(
            #     "return window.innerWidth;")
            # outer_height = driver.execute_script(
            #     "return window.outerHeight;")
            # inner_height = driver.execute_script(
            #     "return window.innerHeight;")
            # body_width = driver.execute_script(
            #     "return document.body.scrollWidth;")
            # body_height = driver.execute_script(
            #     "return document.body.scrollHeight;")
            # logger.info('Original x and y:', x, y)
            # logger.info('Outer Dimensions:', outer_width, outer_height)
            # logger.info('Inner Dimensions:', inner_width, inner_height)
            # logger.info('Body Width:', body_width, 'Body Height:', body_height)
            element = driver.execute_script(
                "return document.elementFromPoint(arguments[0], arguments[1]);", x, y)
            if element:
                try:
                    action = ActionChains(driver)
                    action.move_to_element(element).click().perform()
                    logger.debug(f'Clicked on element at {x}, {y}')
                    return driver
                except MoveTargetOutOfBoundsException:
                    logger.error(f'Failed to click at {x}, {y} due to out of bounds error')
            else:
                logger.warning(f'Element not found at {x}, {y}')
                return driver
        else:
            logger.error("Error in clicking driver")
        
    """ 
    type on the driver
    input:
        --driver: selenium driver : driver to type on
        --key: str : key to type
    algorithm:
        --lock the driver
        --get the active element
        --send the key
    output:
        --driver: selenium driver : driver after typing
    """    
    def type_on_driver(
        self,
        driver,
        key
    ):
        logger.warning("starting typinng process")
        logger.warning("locked .")
        if driver:
            element = driver.switch_to.active_element
            logger.warning(f"Active element: {element.tag_name}" )
            if element:
                try:
                    logger.warning("element got target")
                    element.send_keys(key)
                    return driver
                except MoveTargetOutOfBoundsException:
                    logger.error(f'Failed to type')
            else:
                logger.warning(f'Element not found')
                return driver
        else:
            logger.error("Error in clicking driver")
    
    """
    search on the driver
    input:
        --driver: selenium driver : driver to search on
        --query: str : query to search
    algorithm:
        --lock the driver
        --search on the driver
    output:
        --driver: selenium driver : driver after searching    
    """        
    def search_on_driver(
        self,
        driver,
        query
    ):
        logger.warning("starting searching process")
        logger.warning("locked .")
        if driver:
            try:
                if 'http' or 'https' in query:
                    driver.get(url = query)
                else:
                    nq = query.replace(' ',"+")
                    driver.get(f'https://www.google.com/search?q=a{nq}&oq={nq}&sourceid=chrome&ie=UTF-8')
                return driver
            except Exception as e:
                logger.error(f"Error in searching driver: {e}")
        else:
            logger.error("Error in clicking driver")
    
    """
    hover on the driver
    input:
        --driver: selenium driver : driver to hover on
        --x: int : x coordinate
        --y: int : y coordinate
    algorithm:
        --lock the driver
        --get the element at the x and y coordinates
        --hover on the element
    output:
        --driver: selenium driver : driver after hovering
    """
    def hover_on_driver(
        self,
        driver,
        x,
        y
    ):
        logger.warning("starting hovering process")
        logger.warning("locked .")
        element = driver.execute_script(
            "return document.elementFromPoint(arguments[0], arguments[1]);", x, y)
        if driver:
            try:
                action = ActionChains(driver)
                action.move_to_element(element).perform()
                return driver
            except Exception as e:
                logger.error(f"Error in searching driver: {e}")
        else:
            logger.error("Error in clicking driver")
    
    """
    write to shared memory
    input:
        --screen_data: str : screen data to write
        --audio_data: str : audio data to write
    algorithm:
        --locate shared memory
        --empty the shared memory buffer
        --write to shared memory
    output:
        None
    """            
    def write_to_shared_memory(
        self,
        screen_data,
        audio_data
    ):
        start_time = time.time()
        try:
            shms = shared_memory.SharedMemory(
                name=f"shared_memory_screen_{user_id}", 
                create=False
                )
            shma = shared_memory.SharedMemory(
                name=f"shared_memory_audio_{user_id}", 
                create=False
                )
            if  shms and shma:
                # logger.warning(f"shared memory found for user {user_id}")
                pass
            else:
                # logger.warning(f"shared memory not found for user {user_id}")
                pass
            if not isinstance(
                screen_data, 
                str
            ):
                raise ValueError("Input data must be a string.")
            if not isinstance(
                audio_data, 
                str
            ):
                raise ValueError("Input data must be a string.")
            encoded_data_screen = screen_data.encode('utf-8')
            encoded_data_audio = audio_data.encode('utf-8')
            if len(encoded_data_screen) > shms.size:
                raise ValueError(f"Data size exceeds shared memory size: {len(encoded_data_screen)} / {shms.size}")
            if len(encoded_data_audio) > shma.size:
                raise ValueError(f"Data size exceeds shared memory size: {len(encoded_data_audio)} / {shma.size}")
            shms.buf[:len(encoded_data_screen)] = encoded_data_screen
            shms.buf[len(encoded_data_screen):] = b'\x00' * (shms.size - len(encoded_data_screen))
            shma.buf[:len(encoded_data_audio)] = encoded_data_audio
            shma.buf[len(encoded_data_audio):] = b'\x00' * (shma.size - len(encoded_data_audio))
            # logger.info(f"Successfully wrote string data to shared memory for user {user_id} ({len(encoded_data_screen)} | {len(encoded_data_audio)} bytes)")
        except Exception as e:
            logger.error(f"Failed to write to shared memory for user {user_id}: {e}")
        finally:
            if 'shma' in locals() and 'shms' in locals():
                try:
                    shms.close()
                    shma.close()
                except Exception as close_error:
                    logger.warning(f"Failed to close shared memory for user {user_id}: {close_error}")
            end_time = time.time()
            # logger.info(f"[ MEMORY ] Writing to shared memory took {end_time - start_time:.4f} seconds")

    """
    hit url on browser
    input:
        --driver: selenium driver : driver to hit url on
        --url: str : url to hit
    algorithm:
        --navigate to the url
    output:
        --driver: selenium driver : driver after hitting url
    """
    def hit_url_on_browser(
        self,
        driver,
        url = None
        ):
        url = None
        if url == None:
            url = self.default_url
        """Navigate WebDriver to a URL."""
        start_time = time.time()
        driver.get(url)
        end_time = time.time()
        logger.info(f"[ NAVIGATION ] Browser navigated to {url} in {end_time - start_time:.4f} seconds")
        return driver

    """
    prepare browser for audio capturing
    input:
        --driver: selenium driver : driver to prepare
    algorithm:
        --execute the audio capturing script
    output:
        --driver: selenium driver : driver after preparing
    """
    def prepare_browser_for_audio(
        self,
        driver
    ):
        """Capture a screenshot and write to shared memory."""
        logger.warning("Starting audio tracking script with execjs")
        script = """
        const audioElement = document.querySelector('audio, video');
        if (audioElement) {
            const audioContext = new (window.AudioContext || window.webkitAudioContext)();
            const source = audioContext.createMediaElementSource(audioElement);
            const analyser = audioContext.createAnalyser();
            analyser.fftSize = 1024;
            const dataArray = new Uint8Array(analyser.frequencyBinCount);

            source.connect(analyser);
            analyser.connect(audioContext.destination);

            function logFrequencyData() {
                analyser.getByteFrequencyData(dataArray);
                // Logging the array as a string (JSON format)
                console.log('Array(' + dataArray.length + '): ' + JSON.stringify(Array.from(dataArray)));
                requestAnimationFrame(logFrequencyData);
            }
            logFrequencyData();
        } else {
            console.warn("No audio or video element found.");
        }
        """
        
        try:
            # Execute the script in the browser using Selenium
            driver.execute_script(script)
            logger.warning("Script executed successfully in the browser")
            return driver
        except Exception as e:
            logger.error(f"Error executing script in the browser: {e}")
        
    """
    clear and track log generated by the browser as an audio frequency data
    input:
        --driver: selenium driver : driver to clear and track log
    algorithm:
        --get the browser logs
        --extract the frequency data
        --clear the browser logs
    output:
        --driver: selenium driver : driver after clearing and tracking log
        --fullstring: str : frequency data
    """
    def clear_and_track_log(
        self,
        driver
    ):
        logs = driver.get_log('browser')  # Capture browser logs
        fullstring = '' 
        for log in logs:
            message = log['message']
            if "Array(" in message :
                # Extract the array string part from the log message
                try:
                    # Extract the array part of the message, which is formatted like `Array(512): [ ... ]`
                    start_index = message.find('[')
                    end_index = message.find(']')
                    frequency_data_string = message[start_index:end_index+1]
                    frequency_data_string =  frequency_data_string.replace('[', '').replace(']', '')
                    fullstring += frequency_data_string
                except Exception as e:
                    logger.error(f"Error parsing frequency data: {e}")
        driver.execute_script('console.clear();')
        return driver,fullstring 

    """
    capture and write screenshot and audio
    input:
        None
    algorithm:
        --capture screenshot
        --clear and track log
        --write to shared memory
        --listen to instructions
            --the instructions are:
                --click_on_driver : click on the driver : call  click_on_driver method
                --search : search on the driver : call search_on_driver method
                --keypress : type on the driver : call type_on_driver method
                --hover  : hover on the driver : call hover_on_driver method
        --handle the instructions
    output:
        None
    """
    def capture_and_write_screenshot_and_audio(
        self
    ):
        self.driver = self.prepare_browser_for_audio(
            self.
            driver
        )
        while True:
            try:
                start_time = time.time()
                if self.driver != None:
                    screenshot = self.driver.get_screenshot_as_base64()
                    self.driver,audio = self.clear_and_track_log(
                        self.
                        driver
                    )
                    self.write_to_shared_memory(
                        screenshot,
                        audio
                    )
                    # logger.warning("looking for operators")
                    if self.driver_instruction and self.driver_message:
                        logger.warning("operator cracked")
                        logger.warning(f"printing values {self.driver_instruction} and {self.driver_message}")
                        logger.debug("listening to instruction")
                        logger.warning(f'{type(self.driver_instruction)}')
                        logger.warning(f'{type(self.driver_message)}')
                        if self.driver_message == "click_on_driver":
                            x = int(float(self.driver_instruction['x']))
                            y = int(float(self.driver_instruction['y']))
                            self.driver = self.click_on_driver(
                                driver = self.driver,
                                x = x ,
                                y = y 
                            )
                            logger.debug("click operation complete")
                            self.driver_instruction = None
                            self.driver_message = None
                            logger.debug("wrapping up click")
                        elif self.driver_message == "search":
                            query = self.driver_instruction['qurrey']
                            self.driver = self.search_on_driver(
                                driver=self.
                                driver,
                                query=query
                            )
                            logger.debug("search operation complete")
                            self.driver_instruction = None
                            self.driver_message = None
                            logger.debug("wrapping up click")
                        elif self.driver_message == "keypress":
                            key = self.driver_instruction['key']
                            self.driver = self.type_on_driver(
                                driver=self.driver,
                                key=key
                            )
                            logger.debug("key operation complete")
                            self.driver_instruction = None
                            self.driver_message = None
                            logger.debug("wrapping up type")
                        elif self.driver_message == "hover":
                            x = self.driver_instruction['x']
                            y = self.driver_instruction['y']
                            self.driver = self.hover_on_driver(
                                driver=self.driver,
                                x = x,
                                y = y
                            )
                            logger.debug("hover operation complete")
                            self.driver_instruction = None
                            self.driver_message = None
                            logger.debug("wrapping up hover")
                        elif self.driver_message == "page_source":
                            self.driver = self.set_page_source(
                                driver=self.driver,
                            )
                            logger.debug("page source operation complete")
                            self.driver_instruction = None
                            self.driver_message = None
                            logger.debug("wrapping up page source")
                    # logger.warning("operator bypass")
                else:
                    logger.error("driver is None")
                end_time = time.time()
                # logger.info(f"[ SCREENSHOT ] Captured and wrote screenshot in {end_time - start_time:.4f} seconds")
            except Exception as e:
                logger.error(f"Error capturing screenshot: {e}")
                break

class GeminiAPIClient:
    def __init__(self, api_key):
        self.client = genai.Client(api_key=api_key)
        self.model = "gemini-2.0-flash"

    def generate(self, user_input):
        contents = [
            types.Content(
                role="user",
                parts=[
                    types.Part.from_text(text=user_input),
                ],
            )
        ]

        generate_content_config = types.GenerateContentConfig(
            temperature=2,
            top_p=0.95,
            top_k=40,
            max_output_tokens=8192,
            response_mime_type="application/json",
            system_instruction=[
                types.Part.from_text(
                    text="""  
You are assisting a person with low vision in navigating the internet.  
the details i am providing you is text present on a website I have opened.
Your task is to analyze the provided prompt and determine whether it is:  
1. A **general query** that requires a normal response.  
2. An **action request**, which can be one of the following types:  
   - **Click**: The user wants to click on a specific element.  
   - **fill_search_enter**: The user wants to enter text into an input field.  
   - **Hover**: The user wants to hover over an element for additional information.  

If it is not indicating an action and you think you have a normal query , you just answer it normally. 
send it as a json , only containing like "response" : "your answer" .
for example ,  if the user asks "what is the capital of france" , you would send back "response" : "the capital of france is paris" .
also use markdown in detailed responses .

If the prompt indicates an action, you will receive an **information section** containing elements.
Your response must extract the relevant element and return it in the following format:  
whatever the action you perform or whatever the user ask about an element .
you need to detect the action about , look for the text , in the provided list , 
and return it as in format .
for example , if on a website there is a button sign up .
and the user ask you to click on the sign up button .
you will return the text sign up button , with the format below in a JSON .
action element_text remark response 
for example 
{
    "action": "click",
    "element_text": "Code",
    "remark": "The user wants to click on the Code button.",
    "response": "The Code button has been clicked . please check the website for any changes."
}
do not use "\n" anyway .
for click action , new_generated_text will none .
for fill_search_enter action , new_generated_text will be the text user asked to fill or search . element_text also be there .
if question starts with > , yuo need to explicitly apply an action - for sure .
If no action is detected, simply return a normal response.  
Ensure your output is structured, concise, and relevant to the given prompt.  
"""  
                ),
            ],
        )

        response = self.client.models.generate_content(
            model=self.model,
            contents=contents,
            config=generate_content_config,
        )
        
        return response.text
            
    async def trigger_bridge(self, type, message):
        """Handles different gemini requests and sends responses via WebSocket."""
        if type == "LLM_ask_a_text":
            try:
                logger.debug("Trying to set up LLM response on gemini api")
                # SM.driver , source_info = SM.get_elements_in_viewport(SM.driver)
                label_resp , text_resp , vision_summery= VA.get_info_for_img()
                logger.warning(f"{vision_summery} ||| ")
                org_q = message['message']
                logger.warning(org_q)
                new_question = f"""
                these are the details on website: 
                by vision: {str(vision_summery)}. 
                I will ask questions now.
                my question is {org_q} 
                """
                new_answer = self.generate(new_question)
                logger.warning(new_answer)
                new_answer_dict = json.loads(new_answer)
                if "action" and "element_text" in new_answer_dict.keys():
                    action_required = new_answer_dict["action"].lower().replace('\n','')
                    element_text = new_answer_dict["element_text"].replace('\n','')
                    cord_group = []
                    for key in text_resp.keys():
                        if key in  element_text:
                            cord_group.append(text_resp[key])
                    cord_group = cord_group[:1]
                    logger.warning(f'{cord_group} | {action_required} | {element_text}')
                    if action_required == "click":
                        logger.warning(f"click triggered by ai")
                        new_list = []
                        for a_list in cord_group:
                            new_list = new_list + a_list
                        center_x = sum(point['x'] for point in new_list) / len(new_list)
                        center_y = sum(point['y'] for point in new_list) / len(new_list)
                        center = (center_x, center_y)
                        infodict = {
                            'x':int(center_x),
                            'y':int(center_y),
                        }
                        SM.driver_message = "click_on_driver"
                        SM.driver_instruction =  infodict
                        logger.warning(f"Center coordinates click : {center}")
                    if action_required == "fill_search_enter":
                        logger.warning(f"input triggered by ai")
                        new_list = []
                        for a_list in cord_group:
                            new_list = new_list + a_list
                        center_x = sum(point['x'] for point in new_list) / len(new_list)
                        center_y = sum(point['y'] for point in new_list) / len(new_list)
                        center = (center_x, center_y)
                        infodict = {
                            'x':int(center_x),
                            'y':int(center_y),
                        }
                        new_generated_text = new_answer_dict["new_generated_text"].replace('\n','')
                        new_keypress_dict = {
                            'key':new_generated_text
                        }
                        SM.driver_message = "click_on_driver"
                        SM.driver_instruction =  infodict
                        time.sleep(2)
                        SM.driver_message = "keypress"
                        SM.driver_instruction = new_keypress_dict
                        await WS_CLIENT.send_message(type="LLM_response", message=new_answer)
                else:
                    logger.warning("no action required")
                    await WS_CLIENT.send_message(type="LLM_response", message=new_answer)
                logger.debug("Set up vision response, handing over to thread")
            except Exception as e:
                logger.error(f"Error in setting up LLM response: {e}")
    

class visionApi:
    def __init__(self,file_path):
        self.client = vision.ImageAnnotatorClient.from_service_account_file(file_path)
        self.label_resp = None
        self.text_resp = None
        
    def get_screenshot_content(self):
        try:
            shms = SharedMemory(name=f'shared_memory_screen_{user_id}', create=False)
            buffers = memoryview(shms.buf).tobytes()
            null_index = buffers.find(b'\x00')
            buffers = buffers[:null_index] if null_index != -1 else buffers  
            base64_string = buffers.decode("utf-8")  # Convert bytes to string
            image_bytes = base64.b64decode(base64_string)  # Convert base64 string to bytes
            return image_bytes  # Return raw image bytes
        except Exception as e:
            print(f"Error in get_screenshot_content: {e}")
            return None
        
    def get_info_for_img(self):
        content = self.get_screenshot_content()
        image = vision.Image(content = content)
        lb_response = self.client.label_detection(image = image)
        tx_response  = self.client.text_detection(image = image)
        # logger.warning(lb_response)
        # logger.warning(tx_response)
        labels = [
            {
                "description": label.description,
            }
            for label in lb_response.label_annotations
        ]
        texts = {}
        for text in tx_response.text_annotations:
            texts[text.description] = [
                    {"x": vertex.x, "y": vertex.y} for vertex in text.bounding_poly.vertices
                ]
        vision_summery = []
        for textele in texts.keys():
            vision_summery.append(textele)
        return  labels, texts , vision_summery

    async def trigger_bridge(self, type, message):
        """Handles different vision requests and sends responses via WebSocket."""
        if type == "vision_ask_a_vision":
            try:
                logger.debug("Trying to set up vision response on vision api")
                label_resp , text_resp , vision_summery= self.get_info_for_img()
                self.label_resp = label_resp
                self.text_resp = text_resp
                new_response_json = json.dumps(
                    {
                        "label": label_resp,
                        "text": text_resp,
                        "vision_summery": vision_summery
                    }, ensure_ascii=False)
                await WS_CLIENT.send_message(type="vision_response", message=new_response_json)
                logger.debug("Set up vision response, handing over to thread")
            except Exception as e:
                logger.error(f"Error in setting up vision response: {e}")
    
# Environment variables
user_id = os.environ.get('CONTAINER_USER_ID')
auth_token = os.environ.get('CONTAINER_USER_AUTH_TOKEN')
screendex = os.environ.get('SCREENDEX')
gemini_api_key = os.environ.get('GEMINI_API_KEY')
local_IP = os.environ.get('LOCAL_IP_ADDRESS')

logger.warning(f"{gemini_api_key}")

screendex = screendex.replace('px', '')
screen_width = int(float(
    screendex.split('X')[0])
)
screen_height = int(float(
    screendex.split('X')[1])
)
logger.warning(f"got screen {screen_width} {screen_height}")

logger.debug(f"Starting Docker for user: {user_id}")
websocket_uri = f"ws://{local_IP}:8000/ws/browse/{user_id}/"
SM = selenium_manager()

GAC = GeminiAPIClient(api_key=gemini_api_key)

VA = visionApi(file_path="credscloud.json")

WS_CLIENT = WebSocketClient(
        uri=websocket_uri, 
        user_id=user_id, 
        auth_token=auth_token,
        ip=local_IP,
)
    

"""
main function to start the websocket client and selenium driver
input:
    None
algorithm:
    --start the websocket client
    --send test message
    --write to shared memory
    --setup selenium driver
    --hit url on browser
    --capture and write screenshot and audio
    --keep the main thread alive
output:
    None
"""
def main():
    logger.debug("[ CLIENT ] Starting WebSocket client...")
    client_start = time.time()

    WS_CLIENT.start_in_thread()
    client_end = time.time()
    logger.info(f"[ CLIENT ] WebSocket client setup took {client_end - client_start:.4f} seconds")

    logger.debug("[ CLIENT ] Sending test message to WebSocket server...")
    WS_CLIENT.send_message_thread_safe(
        type="hello", 
        message="Hello, server!"
    )

    logger.debug("[ CLIENT ] Writing to shared memory...")
    
    SM.write_to_shared_memory("Client writing to shared memory.","Client writing to shared memory.")

    logger.debug("[ CLIENT ] Setting up Selenium WebDriver...")
    SM.setup_selenium_driver()

    if SM.driver is None:
        logger.error("[ CLIENT ] WebDriver setup failed.")
        return

    SM.driver = SM.hit_url_on_browser(
        SM.driver
    )

    try:
        screenshot_thread = Thread(
            target=SM.capture_and_write_screenshot_and_audio,
            daemon=True
        )
        screenshot_thread.start()
        # Keep the main thread alive
        while True:
            time.sleep(0.01)

    except KeyboardInterrupt:
        logger.info("[ CLIENT ] Shutting down...")
    finally:
        asyncio.run(WS_CLIENT.close())

"""
the main starter thread
"""
if __name__ == "__main__":
    start_time = time.time()
    main()
    end_time = time.time()
    logger.info(f"[ TOTAL ] Entire script runtime: {end_time - start_time:.4f} seconds")